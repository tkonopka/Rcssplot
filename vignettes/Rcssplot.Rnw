% \VignetteIndexEntry{Styling circlize plots with Rcssplot}
% \VignetteDepends{circlize}
% \VignetteDepends{Rcssplot}
% \VignetteKeywords{circos R}
% \VignetteKeywords{ideogram}
% \VignetteKeywords{circlize}
% \VignetteKeywords{Rcssplot}
% \VignettePackage{circlize}
% \VignetteCompiler{knitr}
% \VignetteEngine{knitr::knitr}


\documentclass{article}

\usepackage[T1]{fontenc}
\usepackage[sc]{mathpazo}
\renewcommand{\sfdefault}{lmss}
\renewcommand{\ttdefault}{lmtt}

\setcounter{tocdepth}{2}

\title{Styling R plots with cascading style sheets and \textbf{Rcssplot}}

\author{Tomasz Konopka {\tt <tomasz.konopka@ludwig.ox.ac.uk>}}
\usepackage[margin=1in, a4paper]{geometry}

\usepackage{hyperref}

\begin{document}

\maketitle 


<<echo = FALSE>>=
library(Rcssplot)
opts_chunk$set(fig.pos = "", fig.align = "center")
showrcss = function(f, remove=4) {
  fcon = file(f, open="r")
  flines = readLines(fcon)
  close(fcon)
  
  ## remove the first few lines
  flines = flines[(remove+1):length(flines)]
  ## remove the last line if empty
  if (flines[length(flines)]=="") {
    flines = flines[1:(length(flines)-1)]
  }
  ## output the contents of the file on screen
  flines = paste(flines, "\n")
  cat(flines)
}
@


\section{Introduction}

\textbf{Rcssplot} is an R package that brings cascading style sheets to the R base graphics environment. It provides a framework for customizing the look of R plots. 

Explain general principles. Explain other graphics packages. 

This document explains the basic principles of creating composite visualizations in R and introduces cascading style sheets and the package \textbf{Rcssplot} as tools to facilitate the process. Although the vignette attempts to introduce the features of \textbf{Rcssplot} ab-initio, familiarity with base graphics and the syntax of css files will be helpful and usually assumed. 



\section{Styling plots with base graphics}

Let's look at styling plots using R's built-in capabilities, called `base graphics'. For concreteness let's use an example with a bar chart. For this we need a data vector.

<<>>=
a = c(5, 8, 10, 11, 12, 12)
names(a) = letters[1:6]
a
@

The function to draw a bar chart in R is {\tt barplot}. We can apply it on our data to obtain a plot with R's default visual style (Figure \ref{fig:base_barplot}A).

<<basebar_1A, eval=FALSE>>=
barplot(a, main="Base graphics")
@

\noindent The default output contains many of the elements that we expect from a bar chart. But there is room for improvement. At a minimum, the chart requires a title and a label for the vertical axis. We might also like to change some colors and spacings. Many of these features can be tuned directly through the {\tt barplot} function (Figure \ref{fig:base_barplot}B).

<<basebar_1B, eval=FALSE>>=
barplot(a, main="Manual tuning", ylab="y label", col="#000080", border=NA, space=0.35)
@

\noindent The function call is now longer, but the output is more complete. 

We can tune the plot a little further using other arguments to the {\tt barplot} function call. However, some aspects of the chart are not accessible directly through the {\tt barplot} function. To overcome these limitations, or to add other custom elements to the chart area, we can create a composite graphic through several function calls. In practice this can be achieved by defining a custom plot function that groups several commands together. 

<<basebarfun_2, eval = FALSE>>=
base.barplot.1 = function(x, main="Custom plot function", ylab="y label") {
  
  ## create a plot with several custom components
  barpos = barplot(x, col="#000080", axes=FALSE, axisnames=FALSE, border=NA, 
                   space=0.35)
  axis(2, col.ticks="#444444", col.axis="#444444", cex.axis=1.2, lwd=1.2, las=1, 
       tck=-0.03, lwd.ticks=1.2)
  axis(1, at=barpos[,1], labels=names(x), lwd=0, col="#111111", cex.axis=1.2, 
       line=-0.35)
  mtext(main, adj=0, line=2.2, cex=1.1)
  submain = paste0("Data range is [", min(x), ", ", max(x), "]")
  mtext(submain, adj=0, line=0.9, cex=0.8, col="#444444")
  mtext(ylab, side=2, cex=0.8, line=3, col="#444444")
}
@

\noindent This function definition takes as input a data vector {\tt x} and two strings for the title and y-axis label. The first line of the function body creates a bar plot without excess decorations. Subsequent lines add axes and text labels. Each command is set up with several custom settings (see R's documentation for details for each). 

We can now apply the custom function on our data (Figure \ref{fig:base_barplot}C).

<<basebar_1C, eval=FALSE>>=
base.barplot.1(a)
@

\noindent The function call is short and simple. Its output is a bar chart that looks legible and sophisticated. Coding of custom plot functions like {\tt base.barplot.1} is the usual way for making composite charts.

<<base_barplot, echo = FALSE, out.width = "1\\textwidth", out.height = "0.25\\textwidth", fig.width = 10, fig.height = 2.5, fig.cap = "Progression of bar charts created with base graphics. (A) Chart with R's barplot function with default settings. (B) Chart produced with R's barplot function with some custom settings. (C) Chart produced with a custom plot function that styles bars, axes, and labels individually. ">>=
par(mfrow = c(1, 3), mar = c(2, 6, 4.8, 2))
<<basebarfun_1>>   
  <<basebarfun_2>>    
  <<basebar_1A>>
text(-2, 15.5, "A", cex=2, xpd=TRUE)
<<basebar_1B>>
text(-2, 15.5, "B", cex=2, xpd=TRUE)
<<basebar_1C>>
text(-2, 15.5, "C", cex=2, xpd=TRUE)
par(mfrow = c(1, 1))
@

Despite the improved output, the custom function approach has some disadvantages. One drawback is that the custom function is now so specialized that it may only be fit for one-time use. Although we can adjust the underlying data and label it appropriately, we cannot easily change any visual aspects without updating the function code. 

Another drawback relates to the fact that the custom function performs two distinct roles. The first role is to combine graphical commands to create a composite data visualization. But the function also performs calculations on the input data: it computes the range of the data and prints this helpful information in a subtitle. In practice it is often helpful to include such simple descriptive statistics within custom plot function. However, this creates a potential tension because during code maintenance we might want to update or improve such calculations. Such maintenance can be hindered by the fact that analysis code is intermixed with commands tuning visual appearance. 




\section{Styling with cascading style sheets}

The \textbf{Rcssplot} package provides a mechanism to style R's graphics that is inspired by cascading style sheets (css) used in web design. In this approach, settings that affect visual representation are stored in a file that is separate from either the data or the code that creates visualizations. 

\subsection{Using \textbf{Rcss} styles}

In \textbf{Rcssplot}, files with style definitions usually have {\tt Rcss} extensions. For this vignette let's begin with a style file called {\tt vignettes.bar1.Rcss}. 

<<barrcss_1, eval=TRUE, echo = FALSE, comment=NA>>=
showrcss("Rcss/vignettes.bar1.Rcss")
@

\noindent The contents consists of a block with the name {\tt barplot}, which corresponds to R's base graphics function for bar charts. Elements within the block are setting/value pairs that correspond to arguments accepted by the R function.

We can read the style definition into the R environment using {\tt Rcss()}.

<<barrcss_load1, eval = TRUE>>=
style1 = Rcss("Rcss/vignettes.bar1.Rcss")
@ 

\noindent We can look inside the object to check that it loaded correctly.

<<barrcss_show, eval = TRUE>>=
style1
printRcss(style1, "barplot")
@

\noindent The first command displays some basic information about the newly loaded style. The second command shows more details for the {\tt barplot} component. In this case we recognize the three argument/value pairs from the {\tt Rcss} file.

Next, we would like to use the cascading style sheet in a plot. The \textbf{Rcssplot} package provides wrappers for many of R's base graphics functions. These wrapper functions have prefixes {\tt Rcss} and accept the usual arguments. For example, to create a barplot, we invoke {\tt Rcssbarplot} (Figure \ref{fig:rcss_barplot}A).

<<rcssbar_2A, eval=FALSE>>=
Rcssbarplot(a, main="Rcssbarplot, unstyled")
@

\noindent When used in plain form as above, the output of the wrapper is exactly the same as from base graphics {\tt barplot}. Let's now add styling by passing our {\tt Rcss} object as an argument (Figure \ref{fig:rcss_barplot}B).

<<rcssbar_2B, eval=FALSE>>=
Rcssbarplot(a, main="Rcssbarplot, styled", Rcss=style1)
@

\noindent The output is analogous to one of the previous examples wherein we specified three arguments within a {\tt barplot} function call (c.f. Figure \ref{fig:base_barplot}B). Here, the same result is achieved with only one argument, with the custom settings extracted automatically from the {\tt Rcss} style sheet. 

In some cases it is useful to override settings defined in a style sheet (Figure \ref{fig:rcss_barplot}C).

<<rcssbar_2C, eval=FALSE>>=
Rcssbarplot(a, main="Rcssbarplot, override", space=1, Rcss=style1)
@

\noindent Here, the width bars is adjusted to a new value using {\tt space} despite this argument being specified in the {\tt Rcss} object. Thus, custom values take precedence over cascading style sheets. 

<<rcss_barplot, echo = FALSE, out.width = "1\\textwidth", out.height = "0.25\\textwidth", fig.width = 10, fig.height = 2.5, fig.cap = "Work-in-progress bar charts created with base graphics and \\textbf{Rcssplot}. (A) Default style bar chart. (B) Chart styled entirely through a style sheet. (C) Chart where some elements are styled through a style sheet and the bar width is set manually within a function call.">>=
par(mfrow = c(1, 3), mar = c(2, 6, 4.8, 2))
<<rcssbarfun_1>>   
  <<rcssbar_2A>>
text(-2, 15.5, "A", cex=2, xpd=TRUE)
<<rcssbar_2B>>
text(-2, 15.5, "B", cex=2, xpd=TRUE)
<<rcssbar_2C>>
text(-2, 15.5, "C", cex=2, xpd=TRUE)
par(mfrow = c(1, 1))
@


\subsection{Using \textbf{Rcss} classes}

Next, let's implement the entire custom bar plot using style sheets. We need additional css definitions from another file {\tt vignettes.bar2.Rcss}. 

<<barrcss_2, eval=TRUE, echo = FALSE, comment=NA>>=
showrcss("Rcss/vignettes.bar2.Rcss")
@

\noindent These definitions are again arranged into blocks that correspond to R's base graphics commands. However, these definition also contain some new features. 

Some blocks contain names with dots followed by a string, e.g. {\tt axis.x}. This is css notation for subclasses that add setting/value definitions that are activated only in particular circumstances. In the case of {\tt axis.x}, the custom definitions pertain to function {\tt Rcssaxis}, but only with an accompanying class label {\tt x}. 

Some blocks also contain names for several base graphics components, e.g. {\tt mtext.ylab, mtext.ylab}. This syntax defines setting/value pairs for several components at once. In this case the syntax is convenient to specify a common color for several components. 

We can now write a new custom function that combines several \textbf{Rcssplot} wrappers.

<<rcssbarfun_1, eval = FALSE>>=
rcss.barplot.1 = function(x, main="Custom Rcss plot", ylab="y label",
  Rcss="default", Rcssclass=c()) {
  
  ## create a plot with several custom components
  barpos = Rcssbarplot(x, axes=FALSE, axisnames=FALSE, Rcss=Rcss, Rcssclass=Rcssclass)
  Rcssaxis(2, Rcss=Rcss, Rcssclass=c(Rcssclass,"y"))
  Rcssaxis(1, at=barpos[,1], labels=names(x), Rcss=Rcss, Rcssclass=c(Rcssclass,"x"))
  Rcssmtext(main, Rcss=Rcss, Rcssclass=c(Rcssclass,"main"))
  submain = paste0("Data range is [", min(x), ", ", max(x), "]")
  Rcssmtext(submain, Rcss=Rcss, Rcssclass=c(Rcssclass, "submain"))
  Rcssmtext(ylab, side=2, Rcss=Rcss, Rcssclass=c(Rcssclass,"ylab"))
}
@

\noindent The structure of this function mirrors {\tt base.barplot.1}, but also accepts an {\tt Rcss} object and a vector {\tt Rcssclass}. Within the function body, all the custom graphical settings are replaced by an {\tt Rcss} argument and a vector for {\tt Rcssclass}. When there are multiple calls to one graphic function (e.g. {\tt Rcssaxis} separately for the x and y axes), the {\tt Rcssclass} vector is ammended with some distinguishing labels. These labels match with the css subclasses we saw previously. 

In practice, the output from the new custom function is a complete plot with all our custom settings (Figure \ref{fig:rcss_custombar}A). 

<<rcssbar_3A, eval=FALSE>>=
style2 = Rcss(c("Rcss/vignettes.bar1.Rcss", "Rcss/vignettes.bar2.Rcss"))
rcss.barplot.1(a, main="Rcss", Rcss=style2)
@

\noindent The first line creates a new style object {\tt style2} using the {\tt Rcss} definitions from both files displayed above. The function call {\tt rcss.barplot.1} then actually creates a chart with the custom style. 

The final output is as before, but the advantage of this approach is that we can now change the visual output by replacing the custom {\tt Rcss} style object with another one. One way to do this is to edit the {\tt Rcss} files directly, to reload the object, and make a new figure with the new style, all independently from the R code in the custom plot function.  

\subsection{Using multiple styles}

Subclasses can also be used to encode multiple styles within one {\tt Rcss} object. Let's look at another set of style definition in file {\tt vignettes.bar3.Rcss}. 

<<barrcss_3, eval=TRUE, echo = FALSE, comment=NA>>=
showrcss("Rcss/vignettes.bar3.Rcss")
@

\noindent These two blocks associated with {\tt barplot} and {\tt mtext} are decorated with a subclass called {\tt typeB}. This class name is not explicitly used within the code of the plot function {\tt rcss.barplot.1}. However, we can prime the plot function to use these definition by passing a subclass during the function call (Figure \ref{fig:rcss_custombar}B).  

<<rcssbar_3B, eval=FALSE>>=
style3 = Rcss(paste0("Rcss/vignettes.bar", c(1, 2, 3), ".Rcss"))
rcss.barplot.1(a, main="Rcss, style3, class typeB", Rcss=style3, Rcssclass="typeB")
@

\noindent The output now incorporates settings defined for the generic {\tt barplot} and {\tt mtext} commands, but also those settings specifically targeted for the {\tt typeB} subclass. When a setting is set both places, the definition with the more specific class takes precedence.

The {\tt Rcssclass} vector is safe to use. When it contains items that are not recognized, these items are just ignored (Figure \ref{fig:rcss_custombar}C).

<<rcssbar_3C, eval=FALSE>>=
rcss.barplot.1(a, main="Rcss, style3, class typeC", Rcss=style3, Rcssclass="typeC")
@

\noindent Here, the class name {\tt typeC} does not appear in the underlying {\tt Rcss} file, so the output is the same as if this subclass was not specified in the first place.

<<rcss_custombar, echo = FALSE, out.width = "1\\textwidth", out.height = "0.25\\textwidth", fig.width = 10, fig.height = 2.5, fig.cap = "Bar plots using base graphics and \\textbf{Rcssplot}. (A) Chart with R's barplot function with default settings. (B) Chart produced with R's barplot function with some custom settings. (C) Chart produced with a custom plot function that styles bars, axes, and labels individually. ">>=
par(mfrow = c(1, 3), mar = c(2, 6, 4.8, 2))
<<rcssbarfun_1>>   
  <<rcssbar_3A>>
text(-2, 15.5, "A", cex=2, xpd=TRUE)
<<rcssbar_3B>>
text(-2, 15.5, "B", cex=2, xpd=TRUE)
<<rcssbar_3C>>
text(-2, 15.5, "C", cex=2, xpd=TRUE)
par(mfrow = c(1, 1))
@

In summary, we saw in this section how to use cascading style sheets to determine the visual appearance of R plots. The new custom plot function is approximately the same length as our original attempt. However, the new function separates the details of visualization from the R code. This makes it easier to tweak visualization (in the {\tt Rcss} files) without worrying about the structure of the R code. It also makes it easier to see the structure of the composite graphic within the custom function because it is not interspersed among dozens of graphical parameters.

The next section describes some additional tricks that can simplify creating custom plot functions with \textbf{Rcssplot}.



\section{Additional features }

This section is organized in roughly independent subsections covering a number of features implemented in \textbf{Rcssplot} to make coding easier.

\subsection{Setting a default style}

In our custom bar chart function, the {\tt Rcss} object appears several times in the plot commands. It is passed as an argument in each call to {\tt barplot}, {\tt axis}, and {\tt mtext}. We can avoid this repetition by setting a default style using {\tt RcssGetDefaultStyle()} and {\tt RcssSetDefaultStyle()}.

<<tricksfun_1, eval = FALSE>>=
rcss.barplot.2 = function(x, main="Custom Rcss plot", ylab="y label",
  Rcss="default", Rcssclass=c()) {
  
  ## use Rcss object to set a default style 
  oldstyle = RcssGetDefaultStyle()
  RcssSetDefaultStyle(Rcss)
  on.exit(RcssSetDefaultStyle(oldstyle))      
  
  ## create a plot with several custom components
  barpos = Rcssbarplot(x, axes=FALSE, axisnames=FALSE, Rcssclass=Rcssclass)
  Rcssaxis(2, Rcssclass=c(Rcssclass, "y"))
  Rcssaxis(1, at=barpos[,1], labels=names(x), Rcssclass=c(Rcssclass, "x"))
  Rcssmtext(main, Rcssclass=c(Rcssclass, "main"))
  submain = paste0("Data range is [", min(x), ", ", max(x), "]")
  Rcssmtext(submain, Rcssclass=c(Rcssclass, "submain"))  
  Rcssmtext(ylab, side=2, Rcssclass=c(Rcssclass, "ylab"))
}
@

\noindent The beginning of the function here obtains the default plot style (if any) and keeps it aside. It then replaces the default style by the style passed in the function call. The {\tt on.exit} command ensures that the default style change is temporary to this custom plot function. The resulting code is a little simpler and thus emphasizes the structure of the chart components. 

It is also possible to set a default {\tt Rcss} style outside of a custom plot function. There are in fact several ways to do this. 

<<tricks_A, eval = FALSE>>=
rcssfiles = paste0("Rcss/vignette.bar", c(1, 2), ".Rcss")
## Option 1 
style2 = Rcss(rcssfiles)
rcss.barplot.2(a, Rcss=style2)
## Option 2
style2 = Rcss(rcssfiles)
RcssSetDefaultStyle(style2)
rcss.barplot.2(a)
## Option 3
Rcss(rcssfiles, default=TRUE)
rcss.barplot.2(a)
@ 

The above code displays three ways to achieve a similar effect. Option 1 is the approach we used in the previous section. We load a custom style and then explicitly pass it to a custom plot function. 

In option 2 we load a custom style and then set it as a global default.  We do not have to pass the style explicitly to the plot function; the default value for the {\tt Rcss} argument is {\tt ''default''}, which instructs the \textbf{Rcssplot} wrappers to use the default style. 

Option 3 is a shorter version of option 2. We load a custom style and set the {\tt default=TRUE} option, which automatically sets the resulting style as a default. With this approach we do not have to create a new object {\tt style2}, and the custom plot functions automatically use the new style.  

Sometimes, we may want to reset the global style. This can be achieved by setting the default style to {\tt NULL}. 

<<tricks_B, eval = FALSE>>=
RcssSetDefaultStyle(NULL)
@ 


\subsection{Overloading base graphics}

Another repetitive element in our custom plot functions is the {\tt Rcss} prefix before each of the plot commands. It is possible to avoid writing this prefix by overloading the base graphics functions with their \textbf{Rcssplot} wrappers using the {\tt RcssOverload()} function. We can incorporate it in our custom function. 

<<tricksfun_2, eval = FALSE>>=
rcss.barplot.3 = function(x, main="Custom Rcss plot", ylab="y label",
  Rcss="default", Rcssclass=c()) {
    
  ## overload base graphics function by Rcss wrappers
  RcssOverload()

  ## use Rcss object to set a default style 
  oldstyle = RcssGetDefaultStyle()
  RcssSetDefaultStyle(Rcss)
  on.exit(RcssSetDefaultStyle(oldstyle))  
  
  ## create a plot with several custom components
  barpos = barplot(x, axes=FALSE, axisnames=FALSE, Rcssclass=Rcssclass)
  axis(2, Rcssclass=c(Rcssclass, "y"))
  axis(1, at=barpos[,1], labels=names(x), Rcssclass=c(Rcssclass, "x"))
  mtext(main, Rcssclass=c(Rcssclass, "main"))
  submain = paste0("Data range is [", min(x), ", ", max(x), "]")
  mtext(submain, Rcssclass=c(Rcssclass, "submain"))  
  mtext(ylab, side=2, Rcssclass=c(Rcssclass, "ylab"))
}
@

\noindent In this custom function, the first step overloads the base graphics functions, making subsequent calls to e.g. {\tt axis} actually invoke the wrapper {\tt Rcssaxis}. The body of the function is thus slightly easier to read and to write.

It is also possible to overload base graphics in the global environment, i.e. outside of the custom plot function. This can be very convenient and it can simplify the custom plot function considerably. 

<<tricksfun_2b, eval = FALSE>>=
rcss.barplot.2b = function(x, main="Custom Rcss plot", ylab="y label",
  Rcssclass=c()) {
      
  ## create a plot with several custom components
  barpos = barplot(x, axes=FALSE, axisnames=FALSE, Rcssclass=Rcssclass)
  axis(2, Rcssclass=c(Rcssclass, "y"))
  axis(1, at=barpos[,1], labels=names(x), Rcssclass=c(Rcssclass, "x"))
  mtext(main, Rcssclass=c(Rcssclass, "main"))
  submain = paste0("Data range is [", min(x), ", ", max(x), "]")
  mtext(submain, Rcssclass=c(Rcssclass, "submain"))  
  mtext(ylab, side=2, Rcssclass=c(Rcssclass, "ylab"))
}
@

\noindent The above function omits the overload step as it assumes that it has been performed in the global environment. The function also assumes that a relevant style is set as default prior to the function call. Thus, the function becomes considerably shorter. The downside of this approach is that the function is no longer independent from the environment; this means that it cannot be reliably transfered from one project to another. Taking so many shortcuts is thus not good practice. Don't do it.


\subsection{Using custom selectors}

Cascading style sheets are versatile and it is possible to create custom definition blocks with custom argument/value pairs. For example, in style file {\tt vignettes.bar4.Rcss}, we see definitions for a selector {\tt barthresholds}. 

<<barrcss_4, eval=TRUE, echo = FALSE, comment=NA>>=
showrcss("Rcss/vignettes.bar4.Rcss")
@

\noindent These blocks do not correspond to any of R's base graphics commands, so they are not directly accessible through any of \textbf{Rcssplot}'s wrappers either. However, such blocks are parsed into {\tt Rcss} objects and can be used within custom plot functions. 

<<tricksfun_3, eval = FALSE>>=
rcss.barplot.3 = function(x, main="", ylab="y label", Rcss="default", Rcssclass=c()) {
    
  RcssOverload()
  oldstyle = RcssGetDefaultStyle()
  RcssSetDefaultStyle(Rcss)
  on.exit(RcssSetDefaultStyle(oldstyle))  
  
  ## extract a quantile value
  qthr = RcssGetPropertyValueOrDefault(Rcss, selector="barthreshold",
    property="q", default=0.5, Rcssclass=Rcssclass)
  qval = as.numeric(quantile(x, p=qthr))
  
  ## create a plot with several custom components
  barpos = barplot(x, axes=FALSE, axisnames=FALSE, Rcssclass=Rcssclass)
  axis(2, Rcssclass=c(Rcssclass, "y"))
  axis(1, at=barpos[,1], labels=names(x), Rcssclass=c(Rcssclass, "x"))
  mtext(main, Rcssclass=c(Rcssclass, "main"))
  abline(h=qval, Rcssclass=Rcssclass)
  submain = paste0("Data range is [", min(x), ", ", max(x), "], q: ",qthr)
  mtext(submain, Rcssclass=c(Rcssclass, "submain"))  
  mtext(ylab, side=2, Rcssclass=c(Rcssclass, "ylab"))
}
@

\noindent In the middle of this function there is a block that extracts a value from the {\tt barthreshold} selector in the {\tt Rcss} object using the {\tt RcssGetPropertyValueOrDefault()} function. The value is interpreted as a quantile. Later in the function, the {\tt abline} command draws a horizontal line at the computed quantile level.

We can call this new plot function using one of our previously defined styles (\ref{fig:rcss_selectors}A).

<<rcssbar_4A, eval = FALSE>>=
rcss.barplot.3(a, main="Custom bars, q default", Rcss=style2)
@ 

\noindent Here, the style object {\tt style2} does not contain the {\tt barthreshold} selector, so the horizontal line is draw at the default quantile level of 0.5.

Let's create a new style that includes the new selector (\ref{fig:rcss_selectors}B).

<<rcssbar_4B, eval = FALSE>>=
style4 = Rcss(paste0("Rcss/vignettes.bar", c(1,2,4), ".Rcss"))
rcss.barplot.3(a, main="Custom bars", Rcss=style4)
@ 

\noindent This new plot has a style horizontal line at the first quartile level. We can also enable a different quantil threshold using the {\tt strict} subclass (\ref{fig:rcss_selectors}C).

<<rcssbar_4C, eval = FALSE>>=
rcss.barplot.3(a, main="Custom bars, subclass", Rcss=style4, Rcssclass="strict")
@ 

<<rcss_selectors, echo = FALSE, out.width = "1\\textwidth", out.height = "0.25\\textwidth", fig.width = 10, fig.height = 2.5, fig.cap = "Bar plots using base graphics, \\textbf{Rcssplot}, and custom selectors. (A) Plot wherein cutoff level is set by a default value defined within a custom plot function. (B) Cutoff level defined through an Rcss custom selector. (C) Cutoff level determined by a subclass through Rcss. ">>=
par(mfrow = c(1, 3), mar = c(2, 6, 4.8, 2))
<<tricksfun_3>>
  <<rcssbar_4A>>
  text(-2, 15.5, "A", cex=2, xpd=TRUE)
<<rcssbar_4B>>
  text(-2, 15.5, "B", cex=2, xpd=TRUE)
<<rcssbar_4C>>
  text(-2, 15.5, "C", cex=2, xpd=TRUE)
par(mfrow = c(1, 1))
@

In this example, the custom selector {\tt barthreshold} does not really only determine a visual component; it actually nudges an analysis component by defining a data threshold. The selector thus implements a choice that pertains to analysis. Is this good practice? Arguably not, because it moves analysis components away from the R code into the cascading style sheet. It thus create a new kind of mixing of analysis and visualization. 

Despite demonstrating potential for abuse, the example shows that custom selector can allow a custom function to affect nonstandard objects. This is particularly useful when designing composite plots with multiple panels.


\subsection{Using a custom color scheme}

To do. 
<<barrcss_5, eval=TRUE, echo = FALSE, comment=NA>>=
showrcss("Rcss/vignettes.bar5.Rcss")
@






\section{Summary}

\section*{Acknowledgements}

\textbf{Rcssplot} is developed on github with contributions from (in alphabetical order): cuche27, nfultz. 





\end{document}
